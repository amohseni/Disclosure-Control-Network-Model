# Calculate skewness and kurtosis for bimodality index
deviations <- flat_similarities - mean_similarity
m3 <- mean(deviations^3) / (sqrt(variance_similarity)^3)  # skewness
m4 <- mean(deviations^4) / (variance_similarity^2)  # kurtosis
# Calculate bimodality index
bimodality_index <- (m3^2 + 1) / m4
return(list(
variance = variance_similarity,
bimodality_index = bimodality_index,
skewness = m3,
kurtosis = m4
))
}
#' Calculate network structure metrics
#'
#' @param graph The network graph
#' @return List of network metrics
calculate_network_metrics <- function(graph) {
# Calculate clustering coefficient
clustering_coeffs <- transitivity(graph, type = "local", isolates = "zero")
avg_clustering <- mean(clustering_coeffs, na.rm = TRUE)
# Calculate average path length
distances <- distances(graph)
finite_distances <- distances[is.finite(distances) & distances > 0]
avg_path_length <- mean(finite_distances)
# Calculate modularity using fast greedy community detection
community <- cluster_fast_greedy(graph)
modularity_value <- modularity(community)
return(list(
avg_clustering = avg_clustering,
clustering_coeffs = clustering_coeffs,
avg_path_length = avg_path_length,
modularity = modularity_value,
communities = community
))
}
#' Calculate disclosure metrics
#'
#' @param disclosure_history History of disclosures
#' @param N Number of agents
#' @param T Number of rounds
#' @param L Length of type vector
#' @return List of disclosure metrics
calculate_disclosure_metrics <- function(disclosure_history, N, T, L) {
# Count total disclosures per agent
agent_disclosures <- numeric(N)
# Count disclosures per trait
trait_disclosures <- numeric(L)
# Process disclosure history
for (t in 1:T) {
for (i in 1:N) {
action <- disclosure_history[[t]][i]
if (action != "reveal nothing") {
agent_disclosures[i] <- agent_disclosures[i] + 1
# Extract which trait was revealed
trait <- extract_trait_number(action)
if (!is.na(trait)) {
trait_disclosures[trait] <- trait_disclosures[trait] + 1
}
}
}
}
# Calculate overall disclosure rate
disclosure_rate <- sum(agent_disclosures) / (N * T)
# Calculate trait-specific disclosure rates
trait_disclosure_rates <- trait_disclosures / (N * T)
return(list(
disclosure_rate = disclosure_rate,
agent_disclosures = agent_disclosures,
trait_disclosure_rates = trait_disclosure_rates
))
}
#' Calculate welfare metrics
#'
#' @param utilities Vector of utility values
#' @return List of welfare metrics
calculate_welfare <- function(utilities) {
# Calculate total welfare
mean_welfare <- mean(utilities)
# Calculate Gini coefficient for inequality measurement
sorted_utilities <- sort(utilities)
n <- length(utilities)
cumulative_utilities <- cumsum(sorted_utilities)
sum_product <- sum((1:n) * sorted_utilities)
# Gini coefficient formula
coefficient_numerator <- (2 * sum_product) - (n + 1) * sum(sorted_utilities)
coefficient_denominator <- n * sum(sorted_utilities)
if (coefficient_denominator > 0) {
gini_coefficient <- coefficient_numerator / coefficient_denominator
} else {
gini_coefficient <- 0
}
return(list(
mean_welfare = mean_welfare,
individual_utilities = utilities,
gini_coefficient = gini_coefficient
))
}
###############################################################
# PART 6: MAIN SIMULATION FUNCTION
###############################################################
#' Run a single simulation round
#'
#' @param graph The network graph
#' @param beliefs Belief array
#' @param types Type matrix
#' @param params List of simulation parameters
#' @param disclosure_type Type of disclosure ("selective" or "global")
#' @param round Current round number
#' @return List containing updated graph, beliefs, and outcomes
run_simulation_round <- function(graph, beliefs, types, params, disclosure_type, round) {
N <- params$N
L <- params$L
delta <- params$delta
s <- params$s
model_version <- params$model_version
# Randomize agent order for this round
agent_order <- sample(1:N)
# Store actions for this round
round_actions <- rep("reveal nothing", N)
# Calculate shortest paths for utility calculations
distances <- distances(graph)
# Process each agent in the randomized order
for (idx in 1:N) {
i <- agent_order[idx]
# For dynamic networks: rewire connections
if (model_version == "dynamic") {
graph <- rewire_connections(graph, i, beliefs, types, L)
# Recalculate distances after rewiring
distances <- distances(graph)
}
# Determine target agents for disclosure
if (disclosure_type == "selective") {
# Random sample of s agents, excluding the current agent
other_agents <- setdiff(1:N, i)
target_agents <- sample(other_agents, min(params$s, N-1))
} else {
# Global disclosure to all agents except self
target_agents <- setdiff(1:N, i)
}
# Decide best action
action_result <- decide_best_action(i, target_agents, distances, beliefs, types, L, delta)
best_action <- action_result$action
round_actions[i] <- best_action
# Update beliefs based on action
if (best_action != "reveal nothing") {
trait_to_reveal <- extract_trait_number(best_action)
if (!is.na(trait_to_reveal)) {
for (j in target_agents) {
beliefs[j, i, trait_to_reveal] <- types[i, trait_to_reveal]
}
}
}
}
# Calculate outcome measures for this round
similarity_matrix <- compute_similarity_matrix(beliefs, types, N, L)
# Store results
outcomes <- list(
similarity = calculate_similarity_outcomes(graph, similarity_matrix, N),
polarization = calculate_polarization_metrics(similarity_matrix),
network = calculate_network_metrics(graph),
utilities = calculate_all_utilities(distances, beliefs, types, N, L, delta),
actions = round_actions
)
# Add welfare metrics
outcomes$welfare <- calculate_welfare(outcomes$utilities)
return(list(
graph = graph,
beliefs = beliefs,
outcomes = outcomes,
round = round
))
}
#' Run a complete simulation
#'
#' @param params List of simulation parameters
#' @return List of simulation results
run_simulation <- function(params) {
# Extract parameters
N <- params$N
L <- params$L
T <- params$T
network_type <- params$network_type
init_type <- params$init_type
model_version <- params$model_version
disclosure_type <- params$disclosure_type
p <- params$p
k <- params$k
b <- params$b
delta <- params$delta
s <- params$s
# Initialize network
graph <- generate_network(network_type, N, p, k)
# Initialize agent type vectors
types <- initialize_types(N, L, init_type, b)
# Initialize belief matrices
beliefs <- initialize_beliefs(N, L, types)
# Initialize storage for simulation results
results <- list(
params = params,
rounds = list(),
disclosure_history = list()
)
# Run simulation for T rounds
for (t in 1:T) {
# Run a single round
round_result <- run_simulation_round(graph, beliefs, types, params, disclosure_type, t)
# Update graph and beliefs
graph <- round_result$graph
beliefs <- round_result$beliefs
# Store results
results$rounds[[t]] <- round_result$outcomes
results$disclosure_history[[t]] <- round_result$outcomes$actions
}
# Calculate overall disclosure metrics
results$disclosure_metrics <- calculate_disclosure_metrics(
results$disclosure_history, N, T, L)
# Store final network state
results$final_network <- graph
results$final_beliefs <- beliefs
return(results)
}
#' Process simulation results for analysis and visualization
#'
#' @param results List of simulation results
#' @return List of processed data frames for analysis
process_simulation_results <- function(results) {
T <- length(results$rounds)
# Extract time series data
rounds_data <- data.frame(
round = 1:T,
neighbor_similarity = sapply(1:T, function(t) results$rounds[[t]]$similarity$neighbor_similarity),
all_similarity = sapply(1:T, function(t) results$rounds[[t]]$similarity$all_similarity),
similarity_gap = sapply(1:T, function(t) results$rounds[[t]]$similarity$similarity_gap),
variance = sapply(1:T, function(t) results$rounds[[t]]$polarization$variance),
bimodality = sapply(1:T, function(t) results$rounds[[t]]$polarization$bimodality_index),
clustering = sapply(1:T, function(t) results$rounds[[t]]$network$avg_clustering),
path_length = sapply(1:T, function(t) results$rounds[[t]]$network$avg_path_length),
modularity = sapply(1:T, function(t) results$rounds[[t]]$network$modularity),
mean_welfare = sapply(1:T, function(t) results$rounds[[t]]$welfare$mean_welfare),
gini = sapply(1:T, function(t) results$rounds[[t]]$welfare$gini_coefficient)
)
# Process disclosure data
disclosure_data <- data.frame(
agent = 1:results$params$N,
disclosures = results$disclosure_metrics$agent_disclosures
)
trait_disclosure_data <- data.frame(
trait = 1:results$params$L,
disclosure_rate = results$disclosure_metrics$trait_disclosure_rates
)
results$params$disclosure_metrics <- results$disclosure_metrics
# Return processed data
return(list(
time_series = rounds_data,
agent_disclosures = disclosure_data,
trait_disclosures = trait_disclosure_data,
params = results$params
))
}
###############################################################
# PART 7: VISUALIZATION FUNCTIONS
###############################################################
#' Create time series plots of key metrics
#'
#' @param processed_results Processed simulation results
#' @return List of ggplot objects
create_time_series_plots <- function(processed_results) {
df <- processed_results$time_series
# Similarity plot
similarity_plot <- ggplot(df, aes(x = round)) +
geom_line(aes(y = neighbor_similarity, color = "Neighbor Similarity"), linewidth = 1) +
geom_line(aes(y = all_similarity, color = "All Similarity"), linewidth = 1) +
geom_line(aes(y = similarity_gap, color = "Similarity Gap"), linewidth = 1, linetype = "dashed") +
labs(title = "Similarity Measures Over Time",
x = "Round",
y = "Similarity",
color = "Measure") +
theme_minimal() +
scale_color_brewer(palette = "Set1")
# Polarization plot
polarization_plot <- ggplot(df, aes(x = round)) +
geom_line(aes(y = variance, color = "Variance"), linewidth = 1) +
geom_line(aes(y = bimodality, color = "Bimodality"), linewidth = 1) +
labs(title = "Polarization Measures Over Time",
x = "Round",
y = "Value",
color = "Measure") +
theme_minimal() +
scale_color_brewer(palette = "Set2")
# Network metrics plot
network_plot <- ggplot(df, aes(x = round)) +
geom_line(aes(y = clustering, color = "Clustering"), linewidth = 1) +
geom_line(aes(y = modularity, color = "Modularity"), linewidth = 1) +
labs(title = "Network Metrics Over Time",
x = "Round",
y = "Value",
color = "Measure") +
theme_minimal() +
scale_color_brewer(palette = "Set3")
# Welfare plot
welfare_plot <- ggplot(df, aes(x = round)) +
geom_line(aes(y = mean_welfare, color = "Total Welfare"), linewidth = 1) +
geom_line(aes(y = gini * 100, color = "Gini Coefficient"), linewidth = 1) +
labs(title = "Welfare Measures Over Time",
x = "Round",
y = "Value",
color = "Measure") +
theme_minimal() +
scale_color_brewer(palette = "Dark2") +
scale_y_continuous(sec.axis = sec_axis(~./100, name = "Gini Coefficient"))
return(list(
similarity = similarity_plot,
polarization = polarization_plot,
network = network_plot,
welfare = welfare_plot
))
}
#' Visualize the network with node colors based on similarity
#'
#' @param graph The network graph
#' @param similarity_matrix Matrix of similarity values
#' @return ggplot object of the network
visualize_network <- function(graph, similarity_matrix) {
# Calculate average similarity for each node
n <- vcount(graph)
avg_similarities <- rowMeans(similarity_matrix, na.rm = TRUE)
# Normalize for color mapping
node_colors <- (avg_similarities - min(avg_similarities)) /
(max(avg_similarities) - min(avg_similarities))
# Get layout
layout <- layout_with_fr(graph)
# Convert to data frames for ggplot
nodes <- data.frame(
id = 1:n,
x = layout[,1],
y = layout[,2],
similarity = avg_similarities
)
edges <- data.frame(
from = ends(graph, E(graph))[,1],
to = ends(graph, E(graph))[,2]
)
edges_for_plot <- data.frame(
x = layout[edges$from, 1],
y = layout[edges$from, 2],
xend = layout[edges$to, 1],
yend = layout[edges$to, 2]
)
# Create network plot
plot <- ggplot() +
geom_segment(data = edges_for_plot, aes(x = x, y = y, xend = xend, yend = yend),
alpha = 0.5) +
geom_point(data = nodes, aes(x = x, y = y, fill = similarity),
shape = 21, size = 5, color = "black") +
scale_fill_gradient(low = "blue", high = "red") +
labs(title = "Network Visualization", fill = "Avg. Similarity") +
theme_void() +
theme(legend.position = "right")
return(plot)
}
###############################################################
# PART 8: PARAMETER SWEEP FUNCTIONS
###############################################################
#' Run multiple simulations with different parameter combinations
#'
#' @param base_params Base parameter list
#' @param param_grid List of parameter grids to sweep
#' @param num_runs Number of runs per parameter combination
#' @return Data frame of aggregated results
run_parameter_sweep <- function(base_params, param_grid, num_runs = 3) {
# Create all combinations of parameters
param_combinations <- expand.grid(param_grid)
# Initialize results storage
num_combinations <- nrow(param_combinations)
results <- list()
# Run simulations for each parameter combination
for (i in 1:num_combinations) {
cat(sprintf("Processing parameter combination %d of %d\n", i, num_combinations))
# Create current parameter set
current_params <- base_params
for (param_name in names(param_combinations)) {
current_params[[param_name]] <- param_combinations[i, param_name]
}
# Run multiple simulations with these parameters
combination_results <- list()
for (run in 1:num_runs) {
cat(sprintf("  Run %d of %d\n", run, num_runs))
sim_result <- run_simulation(current_params)
processed <- process_simulation_results(sim_result)
combination_results[[run]] <- processed
}
# Store aggregated results
results[[i]] <- list(
params = current_params,
runs = combination_results
)
}
# Process and flatten results for analysis
flat_results <- process_sweep_results(results, param_combinations)
return(flat_results)
}
#' Process sweep results into a flat data frame
#'
#' @param results List of simulation results
#' @param param_combinations Data frame of parameter combinations
#' @return Data frame with aggregated metrics
process_sweep_results <- function(results, param_combinations) {
num_combinations <- nrow(param_combinations)
num_runs <- length(results[[1]]$runs)
# Initialize data frame for storing results
result_rows <- list()
for (i in 1:num_combinations) {
for (run in 1:num_runs) {
# Get final round metrics
final_round <- results[[i]]$runs[[run]]$time_series[nrow(results[[i]]$runs[[run]]$time_series), ]
# Create row with parameters and final metrics
row <- c(
as.list(param_combinations[i, ]),
run = run,
final_neighbor_similarity = final_round$neighbor_similarity,
final_all_similarity = final_round$all_similarity,
final_similarity_gap = final_round$similarity_gap,
final_variance = final_round$variance,
final_bimodality = final_round$bimodality,
final_clustering = final_round$clustering,
final_path_length = final_round$path_length,
final_modularity = final_round$modularity,
final_welfare = final_round$mean_welfare,
final_gini = final_round$gini,
disclosure_rate = results[[i]]$runs[[run]]$params$disclosure_metrics$disclosure_rate
)
result_rows[[length(result_rows) + 1]] <- row
}
}
# Convert list to data frame
results_df <- do.call(rbind.data.frame, result_rows)
return(results_df)
}
###############################################################
# PART 9: SAMPLE USAGE
###############################################################
# Example parameter set
example_params <- list(
N = 50,                   # Number of agents
L = 5,                    # Length of type vector
T = 20,                   # Number of rounds
network_type = "WS",      # Network type: "ER", "WS", or "BA"
p = 0.1,                  # Probability parameter for network generation
k = 4,                    # Degree parameter for network generation
init_type = "random",     # Type vector initialization: "random" or "polarized"
b = 0.7,                  # Bias parameter for polarized initialization
delta = 0.5,              # Influence decay factor
s = 10,                   # Size of target subset for selective disclosure
model_version = "static", # Network version: "static" or "dynamic"
disclosure_type = "selective" # Disclosure type: "selective" or "global"
)
# # Run a single simulation (uncomment to run)
# sim_results <- run_simulation(example_params)
# processed_results <- process_simulation_results(sim_results)
# plots <- create_time_series_plots(processed_results)
#
# # Example parameter sweep (uncomment to run)
# param_grid <- list(
#   disclosure_type = c("selective", "global"),
#   model_version = c("static", "dynamic")
# )
# sweep_results <- run_parameter_sweep(example_params, param_grid, num_runs = 2)
# lapply(sweep_results, function(x) if (is.numeric(x)) round(x, 2) else x)
###############################################################
# END OF CODE
###############################################################
values$processed_results$params$disclosure_metrics$disclosure_rate
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
install.packages("shinyBS")
library(shiny)
runApp()
traceback()
runApp()
traceback
runApp()
traceback()
params
runApp()
runApp()
traceback()
runApp()
traceback()
runApp()
runApp()
traceback()
runApp()
traceback
traceback()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
